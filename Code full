/* =============================================================================
 * MICROMOUSE - RIGHT-HAND RULE (STM32F411CEU6 WeAct Black Pill)
 * =============================================================================
 * MCU: STM32F411CEU6, SYSCLK 100MHz, APB1 50MHz (TIM 100MHz), APB2 100MHz
 * 
 * HARDWARE MAPPING:
 * -----------------
 * Motors (TIM5 PWM @ 1kHz):
 *   PA0 = TIM5_CH1 = EN_R  (Right motor enable/PWM)
 *   PA1 = TIM5_CH2 = DIR_R (Right motor direction: 0=FWD, ARR=REV)
 *   PA2 = TIM5_CH3 = EN_L  (Left motor enable/PWM)
 *   PA3 = TIM5_CH4 = DIR_L (Left motor direction: 0=FWD, ARR=REV)
 *
 * IR Sensors (ADC1 + DMA, 4 channels):
 *   PA4 = ADC1_IN4 = IR_raw[0] = Right-Front (RF)
 *   PA5 = ADC1_IN5 = IR_raw[1] = Right-Side (RS)
 *   PA6 = ADC1_IN6 = IR_raw[2] = Left-Side (LS)
 *   PA7 = ADC1_IN7 = IR_raw[3] = Left-Front (LF)
 *
 * Encoders (Quadrature):
 *   Right: TIM4 - PB6=CH1, PB7=CH2
 *   Left:  TIM2 - PA15=CH1, PB3=CH2
 *
 * TUNABLE PARAMETERS (adjust as needed):
 * --------------------------------------
 * - CPR: Counts per revolution (390 default, change if different)
 * - WHEEL_DIAMETER_MM, WHEEL_BASE_MM, CELL_MM: mechanical dimensions
 * - TH_RIGHT, TH_LEFT, TH_FRONT: IR wall detection thresholds
 * - PID constants: KP_STRAIGHT, KD_STRAIGHT, KP_TURN, KD_TURN
 * - BASE_SPEED, TURN_SPEED: motor speeds
 * - INVERT_LEFT_MOTOR, INVERT_RIGHT_MOTOR: if motors spin backwards
 *
 * HOW TO USE:
 * -----------
 * 1. Copy this file into your Keil project (replace main.c)
 * 2. Build and flash to board
 * 3. Robot will run Right-Hand Rule maze solving automatically
 * 4. Adjust parameters above if needed (encoder CPR, IR thresholds, PID gains)
 * 5. Use debugger Watch Window to monitor: IR_raw[], enc_left, enc_right
 *
 * ============================================================================*/

#include "main.h"
#include <stdbool.h>
#include <math.h>

/* External peripheral handles (generated by CubeMX) */
extern ADC_HandleTypeDef hadc1;
extern TIM_HandleTypeDef htim2;  // Left encoder
extern TIM_HandleTypeDef htim4;  // Right encoder
extern TIM_HandleTypeDef htim5;  // PWM for motors & IR

/* =============================================================================
 * TUNABLE PARAMETERS - ADJUST THESE AS NEEDED
 * ===========================================================================*/

// Mechanical parameters
#define CPR                 390    // Counts per revolution (encoder quadrature)
#define WHEEL_DIAMETER_MM   34.0f  // Wheel diameter in mm
#define WHEEL_BASE_MM       88.0f  // Distance between wheels
#define CELL_MM             180.0f // Maze cell size in mm

// IR threshold for wall detection (adjust based on calibration)
uint16_t TH_RIGHT = 900;   // Right side wall threshold
uint16_t TH_LEFT  = 900;   // Left side wall threshold
uint16_t TH_FRONT = 950;   // Front wall threshold

// PID gains for straight driving
#define KP_STRAIGHT  0.7f
#define KD_STRAIGHT  8.0f

// PID gains for turning
#define KP_TURN      2.2f
#define KD_TURN      5.0f

// Motor speeds
#define BASE_SPEED   400   // Base PWM for straight driving (0-999)
#define TURN_SPEED   350   // PWM for turning (0-999)

// Motor inversion flags (set to 1 if motor spins backwards)
#define INVERT_LEFT_MOTOR   0
#define INVERT_RIGHT_MOTOR  0

// PWM limits
#define PWM_MIN      150   // Minimum PWM to move
#define PWM_MAX      999   // Maximum PWM

/* =============================================================================
 * DERIVED CONSTANTS
 * ===========================================================================*/
#define PI 3.14159265f
#define TICKS_PER_MM   ((float)CPR / (PI * WHEEL_DIAMETER_MM))
#define TICKS_PER_DEG  ((WHEEL_BASE_MM * PI / 360.0f) * TICKS_PER_MM)

/* =============================================================================
 * GLOBAL VARIABLES
 * ===========================================================================*/

// ADC DMA buffer for IR sensors
volatile uint16_t IR_raw[4] = {0};  // [0]=RF, [1]=RS, [2]=LS, [3]=LF

// Encoder readings (for debug)
volatile int32_t enc_left = 0;
volatile int32_t enc_right = 0;

/* =============================================================================
 * FUNCTION PROTOTYPES
 * ===========================================================================*/

// Initialization
void system_init(void);
void ir_calibrate_idle(void);

// Motor control
void motor_write(int32_t pwm_left, int32_t pwm_right);
void motors_stop(void);

// Encoder functions
int32_t encoder_read_left(void);
int32_t encoder_read_right(void);
void encoder_reset(void);

// Wall detection
bool wall_right(void);
bool wall_left(void);
bool wall_front(void);

// Motion primitives
void move_mm(float mm);
void turn_deg(float deg);

// Maze solving
void step_one_cell_RHR(void);

// Utility
void delay_ms(uint32_t ms);
int32_t clamp(int32_t val, int32_t min, int32_t max);

/* =============================================================================
 * MAIN FUNCTION
 * ===========================================================================*/

int main(void)
{
  // HAL initialization (done by CubeMX)
  HAL_Init();
  SystemClock_Config();  // Configure clocks (generated by CubeMX)
  MX_GPIO_Init();        // GPIO init
  MX_DMA_Init();         // DMA init
  MX_ADC1_Init();        // ADC init
  MX_TIM2_Init();        // Left encoder
  MX_TIM4_Init();        // Right encoder
  MX_TIM5_Init();        // PWM
  
  // Custom initialization
  system_init();
  
  // Optional: Quick IR calibration (read idle values)
  ir_calibrate_idle();
  
  // Wait for robot to be placed in maze
  delay_ms(2000);
  
  // Main loop: Right-Hand Rule maze solving
  while (1)
  {
    step_one_cell_RHR();
    delay_ms(50);  // Small pause between cells
  }
}

/* =============================================================================
 * INITIALIZATION FUNCTIONS
 * ===========================================================================*/

void system_init(void)
{
  // Start TIM5 PWM on all 4 channels
  HAL_TIM_PWM_Start(&htim5, TIM_CHANNEL_1);  // EN_R
  HAL_TIM_PWM_Start(&htim5, TIM_CHANNEL_2);  // DIR_R
  HAL_TIM_PWM_Start(&htim5, TIM_CHANNEL_3);  // EN_L
  HAL_TIM_PWM_Start(&htim5, TIM_CHANNEL_4);  // DIR_L
  
  // Set TIM5 to 1kHz (assuming CubeMX configured it)
  // If needed: htim5.Instance->PSC = prescaler; htim5.Instance->ARR = 999;
  
  // Start ADC with DMA
  HAL_ADC_Start_DMA(&hadc1, (uint32_t*)IR_raw, 4);
  
  // Start encoders in encoder mode
  HAL_TIM_Encoder_Start(&htim2, TIM_CHANNEL_ALL);  // Left encoder
  HAL_TIM_Encoder_Start(&htim4, TIM_CHANNEL_ALL);  // Right encoder
  
  // Reset encoders
  encoder_reset();
  
  // Stop motors initially
  motors_stop();
}

void ir_calibrate_idle(void)
{
  // Simple calibration: read IR values for 500ms and suggest thresholds
  // User should adjust TH_RIGHT, TH_LEFT, TH_FRONT manually based on these
  delay_ms(500);
  
  // In a real calibration, you would:
  // 1. Read IR_raw[] with no walls nearby (background)
  // 2. Read with walls at standard distance
  // 3. Set thresholds = (background + wall) / 2
  // For now, just use hardcoded thresholds above
}

/* =============================================================================
 * MOTOR CONTROL
 * ===========================================================================*/

void motor_write(int32_t pwm_left, int32_t pwm_right)
{
  // Apply motor inversions if needed
  if (INVERT_LEFT_MOTOR)  pwm_left = -pwm_left;
  if (INVERT_RIGHT_MOTOR) pwm_right = -pwm_right;
  
  // Right motor (CH1=EN, CH2=DIR)
  if (pwm_right >= 0) {
    __HAL_TIM_SET_COMPARE(&htim5, TIM_CHANNEL_2, 0);  // DIR=0 (forward)
    __HAL_TIM_SET_COMPARE(&htim5, TIM_CHANNEL_1, clamp(pwm_right, PWM_MIN, PWM_MAX));
  } else {
    __HAL_TIM_SET_COMPARE(&htim5, TIM_CHANNEL_2, htim5.Instance->ARR);  // DIR=ARR (reverse)
    __HAL_TIM_SET_COMPARE(&htim5, TIM_CHANNEL_1, clamp(-pwm_right, PWM_MIN, PWM_MAX));
  }
  
  // Left motor (CH3=EN, CH4=DIR)
  if (pwm_left >= 0) {
    __HAL_TIM_SET_COMPARE(&htim5, TIM_CHANNEL_4, 0);  // DIR=0 (forward)
    __HAL_TIM_SET_COMPARE(&htim5, TIM_CHANNEL_3, clamp(pwm_left, PWM_MIN, PWM_MAX));
  } else {
    __HAL_TIM_SET_COMPARE(&htim5, TIM_CHANNEL_4, htim5.Instance->ARR);  // DIR=ARR (reverse)
    __HAL_TIM_SET_COMPARE(&htim5, TIM_CHANNEL_3, clamp(-pwm_left, PWM_MIN, PWM_MAX));
  }
}

void motors_stop(void)
{
  motor_write(0, 0);
}

/* =============================================================================
 * ENCODER FUNCTIONS
 * ===========================================================================*/

int32_t encoder_read_left(void)
{
  return (int32_t)(__HAL_TIM_GET_COUNTER(&htim2));
}

int32_t encoder_read_right(void)
{
  return (int32_t)(__HAL_TIM_GET_COUNTER(&htim4));
}

void encoder_reset(void)
{
  __HAL_TIM_SET_COUNTER(&htim2, 0);
  __HAL_TIM_SET_COUNTER(&htim4, 0);
}

/* =============================================================================
 * WALL DETECTION
 * ===========================================================================*/

bool wall_right(void)
{
  return (IR_raw[1] > TH_RIGHT);  // RS sensor
}

bool wall_left(void)
{
  return (IR_raw[2] > TH_LEFT);   // LS sensor
}

bool wall_front(void)
{
  return (IR_raw[0] > TH_FRONT) || (IR_raw[3] > TH_FRONT);  // RF or LF
}

/* =============================================================================
 * MOTION PRIMITIVES
 * ===========================================================================*/

void move_mm(float mm)
{
  int32_t target_ticks = (int32_t)(mm * TICKS_PER_MM);
  encoder_reset();
  
  int32_t last_error = 0;
  
  while (1)
  {
    enc_left = encoder_read_left();
    enc_right = encoder_read_right();
    
    int32_t avg_ticks = (enc_left + enc_right) / 2;
    
    // Check if target reached
    if (avg_ticks >= target_ticks) {
      motors_stop();
      break;
    }
    
    // PID for straight driving: correct based on encoder difference
    int32_t error = enc_right - enc_left;  // Positive = right wheel ahead
    int32_t derivative = error - last_error;
    last_error = error;
    
    float correction = KP_STRAIGHT * error + KD_STRAIGHT * derivative;
    
    // Optional: Add IR bias to stay centered between walls
    // This keeps robot aligned if both walls are present
    if (wall_left() && wall_right()) {
      int32_t ir_error = (int32_t)IR_raw[1] - (int32_t)IR_raw[2];  // RS - LS
      correction += ir_error * 0.1f;  // Small bias term
    }
    
    int32_t pwm_l = BASE_SPEED - (int32_t)correction;
    int32_t pwm_r = BASE_SPEED + (int32_t)correction;
    
    motor_write(pwm_l, pwm_r);
    
    HAL_Delay(5);  // 5ms control loop
  }
}

void turn_deg(float deg)
{
  int32_t target_ticks = (int32_t)(fabs(deg) * TICKS_PER_DEG);
  encoder_reset();
  
  int32_t last_error = 0;
  int32_t direction = (deg > 0) ? 1 : -1;  // Positive = turn left
  
  while (1)
  {
    enc_left = encoder_read_left();
    enc_right = encoder_read_right();
    
    // For turning: left and right encoders move opposite directions
    int32_t avg_ticks = (abs(enc_left) + abs(enc_right)) / 2;
    
    if (avg_ticks >= target_ticks) {
      motors_stop();
      delay_ms(100);  // Settle time
      break;
    }
    
    // PID for turning: minimize encoder difference
    int32_t error = abs(enc_left) - abs(enc_right);
    int32_t derivative = error - last_error;
    last_error = error;
    
    float correction = KP_TURN * error + KD_TURN * derivative;
    
    int32_t pwm = TURN_SPEED;
    int32_t pwm_l = direction * (pwm - (int32_t)correction);
    int32_t pwm_r = -direction * (pwm + (int32_t)correction);
    
    motor_write(pwm_l, pwm_r);
    
    HAL_Delay(5);
  }
}

/* =============================================================================
 * MAZE SOLVING - RIGHT-HAND RULE
 * ===========================================================================*/

void step_one_cell_RHR(void)
{
  // Right-Hand Rule: Priority is Right > Forward > Left > Back
  
  // Always check walls at current position
  bool r = wall_right();
  bool f = wall_front();
  bool l = wall_left();
  
  // Decision logic
  if (!r) {
    // Right is open: turn right and move forward
    turn_deg(-90);  // Turn right
    move_mm(CELL_MM);
  }
  else if (!f) {
    // Right blocked, front open: move forward
    move_mm(CELL_MM);
  }
  else if (!l) {
    // Right and front blocked, left open: turn left and move forward
    turn_deg(90);   // Turn left
    move_mm(CELL_MM);
  }
  else {
    // All directions blocked: turn around
    turn_deg(180);  // U-turn
    move_mm(CELL_MM);
  }
}

/* =============================================================================
 * UTILITY FUNCTIONS
 * ===========================================================================*/

void delay_ms(uint32_t ms)
{
  HAL_Delay(ms);
}

int32_t clamp(int32_t val, int32_t min, int32_t max)
{
  if (val < min) return min;
  if (val > max) return max;
  return val;
}

/* =============================================================================
 * WEAK FUNCTION OVERRIDES (if needed for CubeMX compatibility)
 * ===========================================================================*/

// If SystemClock_Config and MX_ functions are not in your project, 
// you'll need to add them from the CubeMX generated code.
// Typically they should already exist in main.c generated by CubeMX.

/* Example CubeMX generated functions (include if missing):

void SystemClock_Config(void)
{
  // Clock configuration generated by CubeMX
  // HSE 25MHz -> PLL -> SYSCLK 100MHz
}

void MX_TIM5_Init(void)
{
  // TIM5 PWM configuration
  // PSC and ARR set for 1kHz PWM
}

// ... other MX_ init functions
*/
